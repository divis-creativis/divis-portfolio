<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Designer Game</title>
<style>
  :root{
    --bg:#0e6dfd;         /* яскравий фон */
    --bg2:#7fddff;        /* градієнт до низу */
    --hud:#0b1021;        /* темний текст на світлому */
    --chip:#ffffff;
    --accent:#ff7d00;
    --accent2:#00c38a;
    --danger:#ff2b6a;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),var(--bg2));font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;color:var(--hud);overflow:hidden}
  #gameWrap{position:relative;width:100vw;height:100vh}
  canvas{display:block;width:100%;height:100%}

  .hud{
    position:absolute;left:0;right:0;top:0;display:flex;gap:.75rem;
    align-items:center;justify-content:center;flex-wrap:wrap;font-weight:800;
    text-shadow:0 2px 0 rgba(255,255,255,.35);padding:.5rem 1rem;pointer-events:none;user-select:none;
  }
  .chip{background:var(--chip);border:2px solid rgba(0,0,0,.08);border-radius:999px;padding:.3rem .75rem;box-shadow:0 6px 18px rgba(0,0,0,.08)}
  .chip.accent{border-color:var(--accent);color:var(--accent)}
  .chip.good{border-color:var(--accent2);color:var(--accent2)}
  .chip.bad{border-color:var(--danger);color:var(--danger)}

  .overlay{position:absolute;inset:0;display:grid;place-items:center;background:linear-gradient(180deg,rgba(255,255,255,.75),rgba(255,255,255,.85));text-align:center;padding:2rem;color:#0b1021}
  .card{max-width:940px}
  h1{font-size:clamp(28px,5vw,56px);margin:.2em 0}
  p{opacity:.9;line-height:1.45}
  .btn{display:inline-block;margin-top:1rem;background:linear-gradient(90deg,#ff6b6b,#ffd166);color:#101226;font-weight:900;border:none;border-radius:14px;padding:.9rem 1.25rem;font-size:clamp(16px,2.2vw,20px);cursor:pointer;box-shadow:0 12px 30px rgba(255,107,107,.3), inset 0 -4px 0 rgba(0,0,0,.2)}
  .btn:active{transform:translateY(2px)}
  .tips{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:1rem;margin-top:1rem;text-align:left}
  .tips b{color:var(--accent2)}
  .footer{position:absolute;right:.75rem;bottom:.4rem;opacity:.7;font-size:12px;color:#0b1021}
  .legend{margin-top:1rem;opacity:.85;font-size:.95rem}
  .legend code{background:rgba(0,0,0,.06);padding:.1rem .35rem;border-radius:.35rem}
</style>
</head>
<body>
<div id="gameWrap">
  <canvas id="game"></canvas>

  <div class="hud" id="hud">
    <div class="chip">Time: <span id="time">0.0s</span></div>
    <div class="chip good">Points: <span id="points">10000</span></div>
    <div class="chip">Speed: <span id="speed">1.0x</span></div>
    <div class="chip bad">Attached: <span id="mon">0</span></div>
    <div class="chip accent">Best: <span id="best">0.0s</span></div>
  </div>

  <div class="overlay" id="overlay">
    <div class="card">
      <h1>Designer Game</h1>
      <p><b>Goal:</b> Jump over obstacles and <i>survive as long as possible</i> in the graphic-design world.</p>
      <p><b>Rules:</b> You start with <b>10,000 points</b>. Each app-monster that touches you <b>attaches</b> and <b>drains points</b> over time. Speed increases — last as long as you can!</p>
      <div class="tips">
        <div><b>Controls</b><br/>Tap / Click or press <b>Space</b> / <b>↑</b> to jump. <b>P</b> to pause. <b>R</b> to retry.</div>
        <div><b>Obstacles</b><br/>Spikes, wheels, drones, and pits. Monsters carry design-app logos and stick to you if touched.</div>
        <div><b>Audio</b><br/>Funny synthesized sounds for jumps, hits, speed ups, attach, pit fall & game over.</div>
      </div>
      <div class="legend">
        <b>Use your SVG logos</b> — open this file and paste your SVG markup into the <code>ICONS</code> section (look for “PASTE ICON SVGs HERE”). No external files required.
      </div>
      <button class="btn" id="startBtn">Start</button>
    </div>
  </div>

  <div class="footer">© for fun — enjoy!</div>
</div>

<script>
(() => {
  // ======== (1) OPTIONAL: PASTE ICON SVGs HERE =========
  const ICONS = {
    /* приклад:
       ChatGPT: `<svg viewBox="0 0 256 256" ...>...</svg>`
       Якщо не вставляєте, буде fallback-плашка з назвою.
    */
  };

  // Перетворення inline SVG → <img> data URL (без replaceAll для сумісності)
  const iconImgs = {};
  for(const k in ICONS){
    if(ICONS[k] && ICONS[k].trim()){
      const svg = ICONS[k].trim()
        .replace(/\n+/g,' ')
        .replace(/>\s+</g,'><');
      const data = 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg);
      const img = new Image();
      img.decoding = 'async';
      img.src = data;
      iconImgs[k] = img;
    }
  }

  // ======== (2) Canvas sizing =========
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W=innerWidth, H=innerHeight;
  const DPR = Math.min(2, devicePixelRatio||1);
  function resize(){
    W = innerWidth; H = innerHeight;
    canvas.width = Math.floor(W*DPR);
    canvas.height= Math.floor(H*DPR);
    canvas.style.width = W+'px';
    canvas.style.height= H+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
    groundY = Math.floor(H*0.8);
    buildHills();
  }
  addEventListener('resize', resize);

  // ======== (3) HUD =========
  const hudEl = {
    time: document.getElementById('time'),
    points: document.getElementById('points'),
    speed: document.getElementById('speed'),
    mon: document.getElementById('mon'),
    best: document.getElementById('best')
  };
  function fmt(n){ return (Math.round(n*10)/10).toFixed(1); }
  let bestTime = parseFloat(localStorage.getItem('designerGameBest2')||'0')||0;
  hudEl.best.textContent = fmt(bestTime)+'s';

  // ======== (4) Audio =========
  const Audio = {
    ctx: null,
    init(){ if(!this.ctx) this.ctx = new (window.AudioContext||window.webkitAudioContext)(); },
    safeResume(){ try{ if(this.ctx && typeof this.ctx.resume==='function') this.ctx.resume(); }catch(e){} },
    beep({freq=440, dur=0.12, type='sine', vol=0.2, slide=0}={}){
      if(!this.ctx) return;
      const t=this.ctx.currentTime, o=this.ctx.createOscillator(), g=this.ctx.createGain();
      o.type=type; o.frequency.value=freq;
      g.gain.value=0;
      o.connect(g); g.connect(this.ctx.destination);
      g.gain.linearRampToValueAtTime(vol, t+0.01);
      if(slide) o.frequency.linearRampToValueAtTime(freq+slide, t+dur);
      g.gain.linearRampToValueAtTime(0.0001, t+dur);
      o.start(t); o.stop(t+dur+0.02);
    },
    jump(){ this.beep({freq:540, dur:0.11, type:'triangle', vol:0.28, slide:150}); },
    attach(){ this.beep({freq:220, dur:0.20, type:'sawtooth', vol:0.28, slide:-140}); },
    speedUp(){ this.beep({freq:820, dur:0.15, type:'square', vol:0.24, slide:220}); },
    hit(){ this.beep({freq:160, dur:0.12, type:'square', vol:0.27, slide:-80}); },
    pit(){ this.beep({freq:140, dur:0.3, type:'sine', vol:0.3, slide:-240}); },
    gameOver(){ this.beep({freq:360, dur:0.18, type:'sine', vol:0.27, slide:-140}); setTimeout(()=>this.beep({freq:240, dur:0.22, type:'sine', vol:0.24, slide:-90}), 180); }
  };

  // ======== (5) Game State =========
  const START_POINTS = 10000;
  let points=START_POINTS, running=false, paused=false, started=false, time=0, speed=4.2, baseSpeed=4.2, dist=0;
  let groundY = Math.floor(H*0.8);
  let spawnTimer = 0, obstacleTimer=0, last=0, speedUpTimer=0;

  const LABELS = ['ChatGPT','Midjourney','Runway','Photoshop','Figma','LumaLabs','Imagica','Kling','Illustrator','After Effects','Adobe','Pika'];
  const brandColors = {
    ChatGPT:'#00A67E', Midjourney:'#7a5cff', Runway:'#15ff9b', Photoshop:'#31A8FF', Figma:'#F24E1E',
    LumaLabs:'#57f287', Imagica:'#f7a72a', Kling:'#00c2ff', Illustrator:'#FF9A00', 'After Effects':'#9999ff', Adobe:'#FF0000', Pika:'#ff8bd1'
  };

  // Player (трохи яскравіший)
  const player = { x:120, y:0, w:46, h:58, vy:0, onGround:false };
  function drawPlayer(){
    const x=player.x, y=player.y;
    ctx.fillStyle='#2b2d42'; ctx.fillRect(x+8, y+player.h-10, 10, 10); ctx.fillRect(x+28, y+player.h-10, 10, 10);
    const bodyGrad = ctx.createLinearGradient(x, y, x, y+player.h);
    bodyGrad.addColorStop(0,'#ffd166'); bodyGrad.addColorStop(1,'#ff9f1c');
    ctx.fillStyle=bodyGrad; ctx.fillRect(x, y+12, player.w, player.h-18);
    ctx.fillStyle='#ffe2bd'; ctx.fillRect(x+8, y, 30, 24);
    ctx.fillStyle='#23d5ab'; ctx.fillRect(x+6, y-10, 34, 12);
    ctx.fillStyle='#118ab2'; ctx.beginPath(); ctx.arc(x+22, y-2, 18, Math.PI, 0); ctx.fill();
    ctx.fillStyle='#222'; ctx.fillRect(x+15, y+6, 3,4); ctx.fillRect(x+26, y+6, 3,4);
    ctx.strokeStyle='#222'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(x+21, y+12, 8, 0, Math.PI); ctx.stroke();
  }

  // Monsters
  const monsters = [];
  const attached  = [];

  function newMonster(){
    const label = LABELS[Math.floor(Math.random()*LABELS.length)];
    const size = Math.floor(44 + Math.random()*26);
    const y = groundY - size - 10;
    return {
      kind:'monster',
      x: W+40, y, w: size+22, h: size,
      vx:-speed, label, color: brandColors[label] || randColor(),
      attached:false, ix: iconImgs[label] || null
    };
  }

  // Obstacles
  const obstacles = [];
  function newObstacle(){
    const choices = ['spike','wheel','drone','pit'];
    const pick = (time < 8) ? (Math.random()<0.55 ? 'spike':'wheel') : choices[Math.floor(Math.random()*choices.length)];
    if(pick==='pit'){
      const width = 90 + Math.random()*120;
      return { kind:'pit', x:W+40, w:width };
    }
    if(pick==='drone'){
      const size = 36 + Math.random()*18;
      const y = groundY - (100 + Math.random()*140);
      return { kind:'drone', x:W+40, y, w:size+16, h:size, phase: Math.random()*Math.PI*2 };
    }
    if(pick==='wheel'){
      const r = 18 + Math.random()*12;
      const y = groundY - r*2 - 4;
      return { kind:'wheel', x:W+40, y, r, w:r*2, h:r*2, spin:0 };
    }
    const w = 26, h = 36 + Math.random()*18;
    return { kind:'spike', x:W+40, y: groundY - h, w, h };
  }

  // Parallax — світліші яскраві палітри
  const layers=[
    {speed:.25,color:'#79b8ff',hills:[]},
    {speed:.55,color:'#5dd1ff',hills:[]},
    {speed:1.05,color:'#56f1c7',hills:[]},
    {speed:1.6,color:'#7cff7a',hills:[]}
  ];
  function buildHills(){
    layers.forEach((L,i)=>{
      L.hills=[]; let x=0;
      while(x< W*2){
        const w=160+Math.random()*230, h=24+Math.random()*70+i*10;
        L.hills.push({x,w,h}); x+=w*0.8;
      }
    });
  }

  // Physics
  const GRAV=0.78, JUMP=16;

  function jump(){
    if(!running||paused) return;
    if(player.onGround){ player.vy = -JUMP; player.onGround=false; Audio.jump(); }
  }
  addEventListener('keydown', e=>{
    if(e.code==='Space'||e.code==='ArrowUp'){ e.preventDefault(); jump(); }
    if(e.key && e.key.toLowerCase()==='p' && started){ paused=!paused; if(!paused && running) last=performance.now(); }
    if(e.key && e.key.toLowerCase()==='r' && !running && started) startGame();
  });
  addEventListener('pointerdown', jump);

  // Overlay
  const overlay = document.getElementById('overlay');
  const startBtn= document.getElementById('startBtn');
  startBtn.addEventListener('click', ()=>{ Audio.init(); Audio.safeResume(); startGame(); });

  function reset(){
    points=START_POINTS; speed=baseSpeed=4.2; time=0; dist=0;
    monsters.length=0; attached.length=0; obstacles.length=0;
    player.y = groundY - player.h; player.vy=0; player.onGround=true;
    spawnTimer=0; obstacleTimer=0; speedUpTimer=0;
  }
  function startGame(){
    started=true; running=true; paused=false; overlay.style.display='none';
    reset(); last=performance.now(); loop(last);
  }
  function gameOver(msg='You fell into a pit!'){
    running=false; Audio.gameOver();
    bestTime = Math.max(bestTime, time);
    localStorage.setItem('designerGameBest2', String(bestTime));
    hudEl.best.textContent = fmt(bestTime)+'s';
    overlay.style.display='grid';
    overlay.querySelector('.card').innerHTML = `
      <h1>Game Over</h1>
      <p>${msg}</p>
      <p>You survived <b>${fmt(time)}s</b> with <b>${Math.max(0,Math.floor(points))}</b> points. Attached monsters: <b>${attached.length}</b>.</p>
      <button class="btn" id="retryBtn">Retry</button>
    `;
    overlay.querySelector('#retryBtn').addEventListener('click', ()=>{ Audio.safeResume(); startGame(); });
  }

  // Helpers
  function skyAndParallax(){
    // яскраве небо
    const sky = ctx.createLinearGradient(0,0,0,H);
    sky.addColorStop(0,'#9ee8ff');
    sky.addColorStop(0.6,'#89f6d6');
    sky.addColorStop(1,'#b3ffa8');
    ctx.fillStyle=sky; ctx.fillRect(0,0,W,H);

    // легкі «сонячні» промені
    ctx.save();
    ctx.globalAlpha=0.12;
    for(let i=0;i<5;i++){
      const x = (i*W/5 + (dist*0.15)) % (W+200) - 100;
      const g = ctx.createLinearGradient(x,0,x+120,H);
      g.addColorStop(0,'rgba(255,255,255,.0)');
      g.addColorStop(0.5,'rgba(255,255,255,.9)');
      g.addColorStop(1,'rgba(255,255,255,0)');
      ctx.fillStyle=g; ctx.fillRect(x,0,120,H);
    }
    ctx.restore();

    // пагорби
    const baseY=groundY+6;
    layers.forEach(L=>{
      ctx.fillStyle=L.color;
      L.hills.forEach(h=>{
        const x=(h.x - dist*L.speed)%(W*2);
        hill(x, baseY, h.w, h.h); hill(x+W*2, baseY, h.w, h.h);
      });
    });

    // «земля» — світла
    ctx.fillStyle='#d9ffe2'; ctx.fillRect(0, groundY, W, H-groundY);
    ctx.fillStyle='rgba(0,0,0,.06)';
    for(let x= -((dist*2)%60); x<W; x+=60) ctx.fillRect(x, groundY+8, 30, 6);
  }
  function hill(x, baseY, w, h){
    ctx.beginPath(); ctx.moveTo(x,baseY);
    ctx.quadraticCurveTo(x+w*0.5, baseY-h, x+w, baseY);
    ctx.lineTo(x+w,H); ctx.lineTo(x,H); ctx.closePath(); ctx.fill();
  }
  function roundRect(x,y,w,h,r){ const rr=Math.min(r,w/2,h/2); ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y, x+w,y+h, rr); ctx.arcTo(x+w,y+h, x,y+h, rr); ctx.arcTo(x,y+h, x,y, rr); ctx.arcTo(x,y, x+w,y, rr); ctx.closePath(); }
  function drawPlate(x,y,w,h,r=12){
    // непрозора біла плашка під логотип
    ctx.save();
    ctx.shadowColor='rgba(0,0,0,.2)'; ctx.shadowBlur=18; ctx.shadowOffsetY=6;
    ctx.fillStyle='#ffffff';
    roundRect(x, y, w, h, r); ctx.fill();
    ctx.restore();
    ctx.strokeStyle='rgba(0,0,0,.06)'; ctx.lineWidth=2; roundRect(x, y, w, h, r); ctx.stroke();
  }

  function drawMonster(m){
    // плашка
    drawPlate(m.x, m.y, m.w, m.h, 14);

    if(m.ix){
      ctx.drawImage(m.ix, m.x+6, m.y+6, m.w-12, m.h-12);
    }else{
      const r=10; ctx.fillStyle=m.color; roundRect(m.x+6, m.y+6, m.w-12, m.h-12, r); ctx.fill();
      ctx.fillStyle='#000000'; ctx.globalAlpha=0.8;
      ctx.font='700 12px system-ui,Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(m.label, m.x+m.w/2, m.y+m.h/2);
      ctx.globalAlpha=1;
    }

    if(m.attached){
      ctx.strokeStyle='rgba(0,0,0,.35)'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(m.x+m.w/2, m.y+m.h/2); ctx.lineTo(player.x+player.w/2, player.y+player.h/2); ctx.stroke();
    }
  }

  function drawObstacle(o){
    if(o.kind==='pit'){
      ctx.fillStyle='#88d8ff';
      ctx.fillRect(o.x, groundY, o.w, H-groundY);
      ctx.fillStyle='#63c3ff'; ctx.fillRect(o.x-2, groundY, 2, 12); ctx.fillRect(o.x+o.w, groundY, 2, 12);
      return;
    }
    if(o.kind==='spike'){
      const base=groundY, w=o.w, h=o.h, x=o.x;
      ctx.fillStyle='#ff3366';
      ctx.beginPath(); ctx.moveTo(x,base); ctx.lineTo(x+w/2, base-h); ctx.lineTo(x+w, base); ctx.closePath(); ctx.fill();
      ctx.strokeStyle='rgba(0,0,0,.15)'; ctx.stroke();
      return;
    }
    if(o.kind==='wheel'){
      const x=o.x+o.r, y=o.y+o.r;
      ctx.save(); ctx.translate(x,y); ctx.rotate(o.spin||0);
      ctx.fillStyle='#ffd166'; ctx.beginPath(); ctx.arc(0,0,o.r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='#0b1021'; ctx.lineWidth=2;
      ctx.beginPath();
      for(let i=0;i<6;i++){ ctx.moveTo(0,0); ctx.lineTo(o.r*Math.cos(i*Math.PI/3), o.r*Math.sin(i*Math.PI/3)); }
      ctx.stroke();
      ctx.restore();
      return;
    }
    if(o.kind==='drone'){
      const {x,y,w,h}=o;
      const bodyGrad = ctx.createLinearGradient(x,y,x,y+h);
      bodyGrad.addColorStop(0,'#a0c4ff'); bodyGrad.addColorStop(1,'#80ed99');
      drawPlate(x-4,y-4,w+8,h+8,10);
      ctx.fillStyle=bodyGrad; roundRect(x,y,w,h,8); ctx.fill();
      ctx.fillStyle='rgba(16,18,38,.9)';
      ctx.fillRect(x-6, y+2, 6, 3); ctx.fillRect(x+w, y+2, 6, 3);
      ctx.fillRect(x-6, y+h-5, 6, 3); ctx.fillRect(x+w, y+h-5, 6, 3);
      return;
    }
  }

  function randColor(){ return `hsl(${(Math.random()*360)|0} 85% 55%)`; }
  function rectsIntersect(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

  // ======== (6) Loop =========
  function loop(t){
    if(!running) return;
    const dt=Math.min(0.032, (t-last)/1000); last=t;
    if(paused){ requestAnimationFrame(loop); return; }

    // progress
    time+=dt; dist+=speed*120*dt;

    // speed up
    speedUpTimer+=dt;
    if(speedUpTimer>5){ speedUpTimer=0; baseSpeed+=0.42; Audio.speedUp(); }
    speed += (baseSpeed - speed)*0.02;

    // spawn monsters
    spawnTimer -= dt;
    const spawnEvery = Math.max(0.7, 1.8 - time*0.05);
    if(spawnTimer<=0){ monsters.push(newMonster()); spawnTimer=spawnEvery; }

    // spawn obstacles
    obstacleTimer -= dt;
    const obsEvery = Math.max(0.9, 2.1 - time*0.04);
    if(obstacleTimer<=0){ obstacles.push(newObstacle()); obstacleTimer=obsEvery; }

    // physics
    player.vy += GRAV; player.y += player.vy;
    if(player.y + player.h >= groundY){ player.y = groundY - player.h; player.onGround = true; }

    // update monsters
    for(let i=monsters.length-1;i>=0;i--){
      const m=monsters[i];
      if(!m.attached){
        m.x += -speed;
        if(rectsIntersect(player,m)){ m.attached=true; attached.push(m); Audio.attach(); }
        if(m.x + m.w < -140) monsters.splice(i,1);
      }else{
        const idx = attached.indexOf(m);
        const tx = player.x - (idx+1)*60, ty = player.y + 6 + Math.sin((t*0.004)+(i*0.9))*4;
        m.x += (tx - m.x)*0.1; m.y += (ty - m.y)*0.1;
      }
    }

    // update obstacles
    for(let i=obstacles.length-1;i>=0;i--){
      const o=obstacles[i];
      if(o.kind==='pit'){
        o.x += -speed;
        if(player.onGround && (player.x+player.w*0.6>o.x) && (player.x+player.w*0.4<o.x+o.w)){
          Audio.pit(); gameOver('You fell into a pit!');
          return;
        }
        if(o.x + o.w < -80) obstacles.splice(i,1);
      }else if(o.kind==='drone'){
        o.x += -speed*1.1;
        o.phase += dt*4;
        o.y += Math.sin(o.phase)*0.9;
        if(rectsIntersect(player,o)){ points -= 250; Audio.hit(); knockUp(); }
        if(o.x + o.w < -100) obstacles.splice(i,1);
      }else if(o.kind==='wheel'){
        o.x += -speed*1.2; o.spin = (o.spin||0) + dt*6;
        if(rectsIntersect(player,{x:o.x,y:o.y,w:o.w,h:o.h})){ points -= 300; Audio.hit(); knockUp(); }
        if(o.x + o.w < -100) obstacles.splice(i,1);
      }else if(o.kind==='spike'){
        o.x += -speed;
        if(rectsIntersect(player,o)){ points -= 200; Audio.hit(); knockUp(); }
        if(o.x + o.w < -80) obstacles.splice(i,1);
      }
    }

    // drain from attached
    const drainRatePer = 22;
    if(attached.length){ points -= attached.length * drainRatePer * dt; if(points<=0){ points=0; gameOver('Your creative energy was fully drained!'); return; } }

    // draw
    skyAndParallax();

    // легкі «хмарки»
    ctx.globalAlpha=.2; for(let i=0;i<12;i++){ const x=(i*180 - (dist*0.5)%(W+220)) - 120, y=60+(i%5)*28; cloud(x,y); } ctx.globalAlpha=1;

    obstacles.forEach(drawObstacle);
    monsters.forEach(drawMonster);
    drawPlayer();

    // HUD
    hudEl.time.textContent=fmt(time)+'s';
    hudEl.points.textContent=Math.max(0,Math.floor(points));
    hudEl.speed.textContent=(speed/4).toFixed(1)+'x';
    hudEl.mon.textContent=attached.length;

    requestAnimationFrame(loop);
  }

  function knockUp(){
    player.vy = -Math.max(10, JUMP*0.75);
    player.onGround=false;
  }

  function cloud(x,y){ ctx.fillStyle='white'; ctx.beginPath(); ctx.arc(x,y,18,0,Math.PI*2); ctx.arc(x+18,y+6,22,0,Math.PI*2); ctx.arc(x+44,y,16,0,Math.PI*2); ctx.arc(x+60,y+6,12,0,Math.PI*2); ctx.fill(); }

  // ======== (7) Boot =========
  resize(); buildHills();
  player.y = groundY - player.h; player.onGround=true;
})();
</script>
</body>
</html>
