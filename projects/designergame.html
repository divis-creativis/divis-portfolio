<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Designer Game</title>
<style>
  :root{
    --bg:#0b1021;
    --hud:#ffffff;
    --accent:#ffd166;
    --accent2:#06d6a0;
    --danger:#ef476f;
    --ink:#1c2541;
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;color:var(--hud);overflow:hidden}
  #gameWrap{position:relative;width:100vw;height:100vh}
  canvas{display:block;width:100%;height:100%}
  .hud{
    position:absolute;left:0;right:0;top:0;display:flex;gap:.75rem;
    align-items:center;justify-content:center;flex-wrap:wrap;
    font-weight:700; text-shadow:0 2px 0 rgba(0,0,0,.35);
    padding:.5rem 1rem; pointer-events:none; user-select:none;
  }
  .chip{background:rgba(255,255,255,.08);border:2px solid rgba(255,255,255,.18);
    border-radius:999px;padding:.3rem .75rem}
  .chip.accent{border-color:var(--accent);color:var(--accent)}
  .chip.good{border-color:var(--accent2);color:var(--accent2)}
  .chip.bad{border-color:var(--danger);color:var(--danger)}
  .overlay{
    position:absolute;inset:0;display:grid;place-items:center;
    background:linear-gradient(180deg,rgba(16,20,51,.85),rgba(6,8,24,.85));
    text-align:center;padding:2rem
  }
  .card{max-width:900px}
  h1{font-size:clamp(28px,5vw,56px);margin:.2em 0}
  p{opacity:.9;line-height:1.45}
  .btn{
    display:inline-block;margin-top:1rem;background:linear-gradient(90deg,#ff6b6b,#ffd166);
    color:#101226;font-weight:900;border:none;border-radius:14px;
    padding:.9rem 1.25rem;font-size:clamp(16px,2.2vw,20px);cursor:pointer;
    box-shadow:0 10px 30px rgba(255,209,102,.25), inset 0 -4px 0 rgba(0,0,0,.2)
  }
  .btn:active{transform:translateY(2px)}
  .tips{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:1rem;margin-top:1rem;text-align:left}
  .tips b{color:var(--accent2)}
  .footer{
    position:absolute;right:.75rem;bottom:.4rem;opacity:.7;font-size:12px
  }
</style>
</head>
<body>
<div id="gameWrap">
  <canvas id="game"></canvas>

  <div class="hud" id="hud">
    <div class="chip">Time: <span id="time">0.0s</span></div>
    <div class="chip good">Points: <span id="points">10000</span></div>
    <div class="chip">Speed: <span id="speed">1.0x</span></div>
    <div class="chip bad">Monsters: <span id="mon">0</span></div>
    <div class="chip accent">Best: <span id="best">0.0s</span></div>
  </div>

  <div class="overlay" id="overlay">
    <div class="card">
      <h1>Designer Game</h1>
      <p><b>Goal:</b> Jump over obstacles and <i>survive as long as possible</i> in the crazy world of graphic design.</p>
      <p><b>Rules:</b> You start with <b>10,000 points</b>. Each app-monster that hits you <b>sticks</b> and <b>slowly sucks points</b>. The speed rises over time. How long can you last?</p>
      <div class="tips">
        <div><b>Controls</b><br/>Tap / Click or press <b>Space</b> / <b>↑</b> to jump. <b>P</b> to pause.</div>
        <div><b>Win Condition</b><br/>There’s no end — survive and set a record. Retry anytime.</div>
        <div><b>Audio</b><br/>Funny synthesized sounds for jumps, hits, speed ups and game over.</div>
      </div>
      <button class="btn" id="startBtn">Start</button>
    </div>
  </div>

  <div class="footer">© for fun — enjoy!</div>
</div>

<script>
(() => {
  // ---------- Canvas & basic sizing ----------
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W=innerWidth, H=innerHeight;
  const DPR = Math.min(2, devicePixelRatio||1);
  function resize(){
    W = innerWidth; H = innerHeight;
    canvas.width = Math.floor(W*DPR);
    canvas.height= Math.floor(H*DPR);
    canvas.style.width = W+'px';
    canvas.style.height= H+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
    groundY = Math.floor(H*0.78);
  }
  addEventListener('resize', resize);

  // ---------- HUD ----------
  const hudEl = {
    time: document.getElementById('time'),
    points: document.getElementById('points'),
    speed: document.getElementById('speed'),
    mon: document.getElementById('mon'),
    best: document.getElementById('best')
  };
  function fmt(n){ return (Math.round(n*10)/10).toFixed(1); }
  let bestTime = parseFloat(localStorage.getItem('designerGameBest')||'0')||0;
  hudEl.best.textContent = fmt(bestTime)+'s';

  // ---------- Audio (WebAudio, fully local) ----------
  const Audio = {
    ctx: null,
    init(){
      if(!this.ctx) this.ctx = new (window.AudioContext||window.webkitAudioContext)();
    },
    beep({freq=440, dur=0.12, type='sine', vol=0.2, slide=0}={}){
      if(!this.ctx) return;
      const t = this.ctx.currentTime;
      const o = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = 0;
      o.connect(g); g.connect(this.ctx.destination);
      g.gain.linearRampToValueAtTime(vol, t+0.01);
      if(slide !== 0) o.frequency.linearRampToValueAtTime(freq+slide, t+dur);
      g.gain.linearRampToValueAtTime(0.0001, t+dur);
      o.start(t); o.stop(t+dur+0.02);
    },
    jump(){ this.beep({freq:440, dur:0.10, type:'triangle', vol:0.25, slide:120}); },
    attach(){ this.beep({freq:180, dur:0.20, type:'sawtooth', vol:0.25, slide:-100}); },
    speedUp(){ this.beep({freq:700, dur:0.15, type:'square', vol:0.22, slide:160}); },
    gameOver(){
      this.beep({freq:300, dur:0.18, type:'sine', vol:0.25, slide:-120});
      setTimeout(()=>this.beep({freq:220, dur:0.22, type:'sine', vol:0.22, slide:-80}), 180);
    }
  };

  // ---------- Game state ----------
  const START_POINTS = 10000;
  let points = START_POINTS;
  let running = false, paused=false, started=false, time=0, speed=4, baseSpeed=4, dist=0;
  let groundY = Math.floor(H*0.78);
  let spawnTimer = 0;
  const LABELS = [
    'ChatGPT','Midjourney','Runway','Photoshop','Figma','Luma AI','Imagica AI','Kling AI','Illustrator','After Effects'
  ];
  const brandColors = {
    'ChatGPT':'#00A67E','Midjourney':'#7a5cff','Runway':'#15ff9b','Photoshop':'#31A8FF','Figma':'#F24E1E',
    'Luma AI':'#57f287','Imagica AI':'#f7a72a','Kling AI':'#00c2ff','Illustrator':'#FF9A00','After Effects':'#9999ff'
  };

  // Player
  const player = {
    x: 120, y: 0, w: 46, h: 58, vy: 0, onGround: false,
    draw(){
      // Cartoon body
      const x=this.x, y=this.y;
      // legs
      ctx.fillStyle = '#222'; ctx.fillRect(x+8, y+this.h-10, 10, 10);
      ctx.fillRect(x+28, y+this.h-10, 10, 10);
      // body
      const bodyGrad = ctx.createLinearGradient(x, y, x, y+this.h);
      bodyGrad.addColorStop(0,'#ffe66d'); bodyGrad.addColorStop(1,'#fcbf49');
      ctx.fillStyle = bodyGrad; ctx.fillRect(x, y+12, this.w, this.h-18);
      // head
      ctx.fillStyle = '#ffd7a8'; ctx.fillRect(x+8, y, 30, 24);
      // cap
      ctx.fillStyle = '#06d6a0'; ctx.fillRect(x+6, y-10, 34, 12); // brim
      ctx.fillStyle = '#118ab2'; ctx.beginPath();
      ctx.arc(x+22, y-2, 18, Math.PI, 0); ctx.fill();
      // eyes & smile
      ctx.fillStyle = '#222'; ctx.fillRect(x+15, y+6, 3,4); ctx.fillRect(x+26, y+6, 3,4);
      ctx.strokeStyle='#222'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(x+21, y+12, 8, 0, Math.PI); ctx.stroke();
    }
  };

  // Monsters (apps)
  const monsters = [];
  const attached = []; // monsters attached to the player
  function newMonster(){
    const label = LABELS[Math.floor(Math.random()*LABELS.length)];
    const size = Math.floor(40 + Math.random()*22);
    const y = groundY - size - 8;
    return {
      x: W + 40,
      y,
      w: size+18,
      h: size,
      vx: -speed,
      label,
      color: brandColors[label] || `hsl(${(Math.random()*360)|0}deg 70% 60%)`,
      attached:false
    };
  }

  // Parallax layers (simple colorful shapes)
  const layers = [
    { speed: 0.2, color:'#151a37', hills:[] },
    { speed: 0.5, color:'#1d2450', hills:[] },
    { speed: 1.0, color:'#27306d', hills:[] },
    { speed: 1.6, color:'#33409a', hills:[] }
  ];
  function buildHills(){
    layers.forEach((L,i)=>{
      L.hills = [];
      let x=0;
      while(x < W*2){
        const w = 180 + Math.random()*240;
        const h = 30 + Math.random()*80 + i*8;
        L.hills.push({x, w, h});
        x += w*0.8;
      }
    });
  }

  // Physics
  const GRAV= 0.78;
  const JUMP= 16;

  // Input
  function jump(){
    if(!running || paused) return;
    if(player.onGround){
      player.vy = -JUMP;
      player.onGround = false;
      Audio.jump();
    }
  }
  addEventListener('keydown', e=>{
    if(e.code==='Space' || e.code==='ArrowUp') { e.preventDefault(); jump(); }
    if(e.key.toLowerCase()==='p' && started){ paused=!paused; if(!paused && running) last=performance.now(); }
    if(e.key.toLowerCase()==='r' && !running && started) startGame();
  });
  addEventListener('pointerdown', jump);

  // Overlay + controls
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');
  startBtn.addEventListener('click', ()=>{
    Audio.init();
    Audio.ctx.resume?.();
    startGame();
  });

  function reset(){
    points = START_POINTS;
    speed = baseSpeed = 4;
    time = 0; dist=0;
    monsters.length = 0;
    attached.length = 0;
    player.y = groundY - player.h;
    player.vy = 0;
    player.onGround = true;
    spawnTimer = 0;
  }

  function startGame(){
    started = true; running = true; paused=false;
    overlay.style.display='none';
    reset();
    last = performance.now();
    loop(last);
  }

  function gameOver(){
    running=false;
    Audio.gameOver();
    bestTime = Math.max(bestTime, time);
    localStorage.setItem('designerGameBest', String(bestTime));
    hudEl.best.textContent = fmt(bestTime)+'s';
    overlay.style.display='grid';
    overlay.querySelector('.card').innerHTML = `
      <h1>Game Over</h1>
      <p>You survived for <b>${fmt(time)}s</b> with <b>${Math.max(0,Math.floor(points))}</b> points remaining.</p>
      <p>Attached monsters: <b>${attached.length}</b> — they drained your energy! Try again and jump earlier.</p>
      <button class="btn" id="retryBtn">Retry</button>
    `;
    overlay.querySelector('#retryBtn').addEventListener('click', ()=>{
      Audio.ctx && Audio.ctx.resume?.();
      startGame();
    });
  }

  // ---------- Drawing ----------
  function drawBackground(dt){
    // sky gradient
    const sky = ctx.createLinearGradient(0,0,0,H);
    sky.addColorStop(0,'#0b0f2b'); sky.addColorStop(1,'#0b1021');
    ctx.fillStyle = sky; ctx.fillRect(0,0,W,H);

    // stars
    ctx.save();
    ctx.globalAlpha = .15;
    for(let i=0;i<60;i++){
      const x = (i*97.3 + dist*0.02) % W;
      const y = (i*59.7 % Math.max(180,H*0.6));
      ctx.fillStyle = i%7? '#a2d2ff':'#ffd166';
      ctx.fillRect(x, y, 2,2);
    }
    ctx.restore();

    // parallax hills
    const baseY = groundY+6;
    layers.forEach(L=>{
      ctx.fillStyle = L.color;
      L.hills.forEach(h=>{
        const x = (h.x - dist*L.speed) % (W*2);
        ctx.beginPath();
        ctx.moveTo(x, baseY);
        ctx.quadraticCurveTo(x + h.w*0.5, baseY - h.h, x + h.w, baseY);
        ctx.lineTo(x + h.w, H);
        ctx.lineTo(x, H);
        ctx.closePath();
        ctx.fill();
        // second copy for seamless wrap
        const x2 = x + W*2;
        ctx.beginPath();
        ctx.moveTo(x2, baseY);
        ctx.quadraticCurveTo(x2 + h.w*0.5, baseY - h.h, x2 + h.w, baseY);
        ctx.lineTo(x2 + h.w, H);
        ctx.lineTo(x2, H);
        ctx.closePath();
        ctx.fill();
      });
    });

    // ground line
    ctx.fillStyle = '#172042';
    ctx.fillRect(0, groundY, W, H-groundY);
    // stripes
    ctx.fillStyle = 'rgba(255,255,255,.06)';
    for(let x= -((dist*2)%60); x < W; x+=60){
      ctx.fillRect(x, groundY+8, 30, 6);
    }
  }

  function drawMonster(m){
    // rounded rect
    const r = 10;
    ctx.fillStyle = m.color;
    roundRect(ctx, m.x, m.y, m.w, m.h, r);
    ctx.fill();
    // eyes (goofy)
    ctx.fillStyle = '#101226';
    ctx.beginPath(); ctx.arc(m.x + m.w*0.3, m.y + m.h*0.35, 4, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(m.x + m.w*0.7, m.y + m.h*0.35, 4, 0, Math.PI*2); ctx.fill();
    // mouth
    ctx.fillStyle = '#0b1021';
    roundRect(ctx, m.x + m.w*0.3, m.y + m.h*0.6, m.w*0.4, 8, 4); ctx.fill();
    // label as faux "logo"
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 12px system-ui,Arial';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(m.label, m.x + m.w/2, m.y + m.h/2);
    // attachment tether
    if(m.attached){
      ctx.strokeStyle='rgba(255,255,255,.4)';
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(m.x+m.w/2, m.y+m.h/2);
      ctx.lineTo(player.x+player.w/2, player.y+player.h/2);
      ctx.stroke();
    }
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  // ---------- Game Loop ----------
  let last=0, speedUpTimer=0;
  function loop(t){
    if(!running){ return; }
    const dt = Math.min(0.032, (t-last)/1000); // clamp
    last = t;
    if(paused){ requestAnimationFrame(loop); return; }

    // progress
    time += dt;
    dist += speed*120*dt;

    // increase speed smoothly
    speedUpTimer += dt;
    if(speedUpTimer > 5){
      speedUpTimer = 0;
      baseSpeed += 0.4;
      Audio.speedUp();
    }
    speed += (baseSpeed - speed)*0.02;

    // spawn monsters
    spawnTimer -= dt;
    const spawnEvery = Math.max(0.7, 1.8 - time*0.05);
    if(spawnTimer <= 0){
      monsters.push(newMonster());
      spawnTimer = spawnEvery;
    }

    // update physics
    player.vy += GRAV;
    player.y += player.vy;
    if(player.y + player.h >= groundY){
      player.y = groundY - player.h;
      player.onGround = true;
    }

    // update monsters
    for(let i=monsters.length-1;i>=0;i--){
      const m = monsters[i];
      if(!m.attached){
        m.x += -speed;
        // collision
        if(rectsIntersect(player, m)){
          m.attached = true;
          attached.push(m);
          Audio.attach();
        }
        if(m.x + m.w < -100) monsters.splice(i,1);
      }else{
        // follow around player (stick)
        const targetX = player.x - (attached.indexOf(m)+1)*58;
        const targetY = player.y + 6 + Math.sin((t*0.004)+(i*0.9))*4;
        m.x += (targetX - m.x) * 0.1;
        m.y += (targetY - m.y) * 0.1;
      }
    }

    // drain points by attached monsters
    const drainRatePer = 22; // pts/sec per monster
    if(attached.length){
      points -= attached.length * drainRatePer * dt;
      if(points <= 0){
        points = 0;
        gameOver();
      }
    }

    // draw
    drawBackground(dt);
    // clouds (front)
    ctx.globalAlpha = .15;
    for(let i=0;i<10;i++){
      const x = (i*180 - (dist*0.7)% (W+220)) - 120;
      const y = 50 + (i%5)*26;
      drawCloud(x,y);
    }
    ctx.globalAlpha = 1;

    monsters.forEach(drawMonster);
    player.draw();

    // HUD update
    hudEl.time.textContent = fmt(time)+'s';
    hudEl.points.textContent = Math.max(0, Math.floor(points));
    hudEl.speed.textContent = (speed/4).toFixed(1)+'x';
    hudEl.mon.textContent = attached.length;

    requestAnimationFrame(loop);
  }

  function drawCloud(x,y){
    ctx.fillStyle='white';
    ctx.beginPath();
    ctx.arc(x,y,18,0,Math.PI*2);
    ctx.arc(x+18,y+6,22,0,Math.PI*2);
    ctx.arc(x+44,y,16,0,Math.PI*2);
    ctx.arc(x+60,y+6,12,0,Math.PI*2);
    ctx.fill();
  }

  function rectsIntersect(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  // ---------- Boot ----------
  resize(); buildHills();
})();
</script>
</body>
</html>
